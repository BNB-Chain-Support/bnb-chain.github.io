"use strict";(self.webpackChunkbeta_BNB_Docs=self.webpackChunkbeta_BNB_Docs||[]).push([[3259],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>f});var o=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)a=i[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)a=i[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=o.createContext({}),c=function(e){var t=o.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},h=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(a),p=n,f=d["".concat(l,".").concat(p)]||d[p]||u[p]||i;return a?o.createElement(f,r(r({ref:t},h),{},{components:a})):o.createElement(f,r({ref:t},h))}));function f(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:n,r[1]=s;for(var c=2;c<i;c++)r[c]=a[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,a)}p.displayName="MDXCreateElement"},10597:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var o=a(87462),n=(a(67294),a(3905));const i={sidebar_label:"Consensus Engine",sidebar_position:2,hide_table_of_contents:!1},r="Consensus Engine",s={unversionedId:"learn/consensus",id:"learn/consensus",title:"Consensus Engine",description:"Although Proof-of-Work (PoW) has been recognized as a practical mechanism to implement a decentralized network, it is not friendly to the environment and also requires a large size of participants to maintain the security.",source:"@site/docs/learn/consensus.md",sourceDirName:"learn",slug:"/learn/consensus",permalink:"/docs/learn/consensus",draft:!1,editUrl:"https://github.com/bnb-chain/bnb-chain.github.io/blob/master/docs/learn/consensus.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Consensus Engine",sidebar_position:2,hide_table_of_contents:!1},sidebar:"bscSideBar",previous:{title:"Tutorials",permalink:"/docs/bsc-tutorials"},next:{title:"Architecture",permalink:"/docs/learn/cross-chain"}},l={},c=[{value:"Validator Quorum",id:"validator-quorum",level:2},{value:"Parlia",id:"parlia",level:2},{value:"Light Client Security",id:"light-client-security",level:3},{value:"System Transaction",id:"system-transaction",level:3},{value:"Enforce Backoff",id:"enforce-backoff",level:3},{value:"Extending the ruling of the current validator set via temporary censorship",id:"extending-the-ruling-of-the-current-validator-set-via-temporary-censorship",level:3},{value:"Security",id:"security",level:2},{value:"Fast Finality",id:"fast-finality",level:2}],h={toc:c},d="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(d,(0,o.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"consensus-engine"},"Consensus Engine"),(0,n.kt)("p",null,"Although Proof-of-Work (PoW) has been recognized as a practical mechanism to implement a decentralized network, it is not friendly to the environment and also requires a large size of participants to maintain the security."),(0,n.kt)("p",null,"Ethereum and some other blockchain networks, such as ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/maticnetwork/bor"},"MATIC Bor"),", ",(0,n.kt)("a",{parentName:"p",href:"https://tomochain.com/"},"TOMOChain"),", ",(0,n.kt)("a",{parentName:"p",href:"https://gochain.io/"},"GoChain"),", ",(0,n.kt)("a",{parentName:"p",href:"https://xdai.io/"},"xDAI"),", do use ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Proof_of_authority"},"Proof-of-Authority(PoA)")," or its variants in different scenarios, including both testnet and mainnet. PoA provides some defense to 51% attack, with improved efficiency and tolerance to certain levels of Byzantine players (malicious or hacked). It serves as an easy choice to pick as the fundamentals."),(0,n.kt)("p",null,"Meanwhile, the PoA protocol is most criticized for being not as decentralized as PoW, as the validators, i.e. the nodes that take turns to produce blocks, have all the authorities and are prone to corruption and security attacks. Other blockchains, such as EOS and Lisk both, introduce different types of ",(0,n.kt)("a",{parentName:"p",href:"https://en.bitcoinwiki.org/wiki/DPoS"},"Delegated Proof of Stake (DPoS)")," to allow the token holders to vote and elect the validator set. It increases the decentralization and favors community governance."),(0,n.kt)("p",null,"BSC here proposes to combine DPoS and PoA for consensus, so that:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Blocks are produced by a limited set of validators"),(0,n.kt)("li",{parentName:"ol"},"Validators take turns to produce blocks in a PoA manner, similar to ",(0,n.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-225"},"Ethereum's Clique")," consensus design"),(0,n.kt)("li",{parentName:"ol"},"Validator set are elected in and out based on a staking based governance")),(0,n.kt)("p",null,"Fast finalization can greatly improve user experience. The ",(0,n.kt)("inlineCode",{parentName:"p"},"Fast Finality")," feature will be enabled upon the coming Plato upgrade. This will be a major advantage of BSC, and many dapps will benefit from it."),(0,n.kt)("p",null,"The consensus protocol of BSC fulfills the following goals:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Short Blocking time, 3 seconds on mainnet."),(0,n.kt)("li",{parentName:"ol"},"It requires quite short time to confirm the finality of transactions, around 6s for mainnet after the coming Plato upgrade."),(0,n.kt)("li",{parentName:"ol"},"There is no inflation of native token: BNB, the block reward is collected from transaction fees, and it will be paid in BNB."),(0,n.kt)("li",{parentName:"ol"},"It is 100% compatible with Ethereum system ."),(0,n.kt)("li",{parentName:"ol"},"It allows modern proof-of-stake blockchain network governance.")),(0,n.kt)("h2",{id:"validator-quorum"},"Validator Quorum"),(0,n.kt)("p",null,"In the genesis stage, a few trusted nodes will run as the initial Validator Set. After the blocking starts, anyone can compete to join as candidates to elect as a validator. The staking status decides the top 29 most staked nodes to be the next validator set, and such an election will repeat every 24 hours."),(0,n.kt)("p",null,"BNB is the token used to stake for BSC."),(0,n.kt)("p",null,"In order to remain as compatible as Ethereum and upgradeable to future consensus protocols to be developed, BSC chooses to rely on the BC for staking management. There is a dedicated staking module for BSC on BC. It will accept BSC staking from BNB holders and calculate the highest staked node set. Upon every UTC midnight, BC will issue a verifiable ",(0,n.kt)("strong",{parentName:"p"},"ValidatorSetUpdate")," cross-chain message to notify BSC to update its validator set."),(0,n.kt)("p",null,"While producing further blocks, the existing BSC validators check whether there is a ",(0,n.kt)("strong",{parentName:"p"},"ValidatorSetUpdate")," message relayed onto BSC periodically. If there is, they will update the validator set after an ",(0,n.kt)("strong",{parentName:"p"},"epoch period"),", i.e. a predefined number of blocking time. For example, if BSC produces a block every 5 seconds, and the epoch period is 240 blocks, then the current validator set will check and update the validator set for the next epoch in 1200 seconds (20 minutes)."),(0,n.kt)("h2",{id:"parlia"},"Parlia"),(0,n.kt)("p",null,"The implement of the consensus engine is named as ",(0,n.kt)("strong",{parentName:"p"},"Parlia")," which is similar to ",(0,n.kt)("a",{parentName:"p",href:"https://ethereum-magicians.org/t/eip-225-clique-proof-of-authority-consensus-protocol/1853"},"clique"),". This doc will focus more on the difference and ignore the common details."),(0,n.kt)("h3",{id:"light-client-security"},"Light Client Security"),(0,n.kt)("p",null,"Validators set changes take place at the (epoch+N/2) blocks. (N is the size of validatorset before epoch block). Considering the security of light client, we delay N/2 block to let validatorSet change take place."),(0,n.kt)("p",null,"Every epoch block, validator will query the validatorset from contract and fill it in the extra_data field of block header. Full node will verify it against the validatorset in contract. A light client will use it as the validatorSet for next epoch blocks, however, it can not verify it against contract, it have to believe the signer of the epoch block. If the signer of the epoch block write a wrong extra_data, the light client may just go to a wrong chain. If we delay N/2 block to let validatorSet change take place, the wrong\nepoch block won\u2019t get another N/2 subsequent blocks that signed by other validators, so that the light client are free of such attack."),(0,n.kt)("h3",{id:"system-transaction"},"System Transaction"),(0,n.kt)("p",null,"The consensus engine may invoke system contracts, such transactions are called system transactions. System transactions is signed by the the validator who is producing the block. For the witness node, will generate the system transactions(without signature) according to its intrinsic logic and compare them with the system transactions in the block before applying them."),(0,n.kt)("h3",{id:"enforce-backoff"},"Enforce Backoff"),(0,n.kt)("p",null,"In Clique consensus protocol, out-of-turn validators have to wait a randomized amount of time before sealing the block. It is implemented in the client-side node software and works with the assumption that validators would run the canonical version.\nHowever, given that validators would be economically incentivized to seal blocks as soon as possible, it would be possible that the validators would run a modified version of the node software to ignore such a delay. To prevent validator rushing to seal a block, every out-turn validator will get a specified time slot to seal the block. Any block with a earlier blocking time produced by an out-turn validator will be discarded by other witness node."),(0,n.kt)("h3",{id:"extending-the-ruling-of-the-current-validator-set-via-temporary-censorship"},"Extending the ruling of the current validator set via temporary censorship"),(0,n.kt)("p",null,"If the transaction that updates the validator is sent to the BSC right on the epoch period, then it is possible for the in-turn validator to censor the transaction and not change the set of validators for that epoch. While a transaction cannot be forever censored without the help of other n/2 validators, by this it can extend the time of the current validator set and gain some rewards. In general, the probability of this scheme can increase by colluding with other validators. It is relatively benign issue that a block may be approximately 3 secs and one epoch being 200 blocks, i.e. 20 mins so the validators could only be extended for another 10 mins."),(0,n.kt)("h2",{id:"security"},"Security"),(0,n.kt)("p",null,"Given there are more than \xbd","*","N+1 validators are honest, PoA based networks usually work securely and properly. However, there are still cases where certain amount Byzantine validators may still manage to attack the network, e.g. through the ",(0,n.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1902.10244.pdf"},"Clone Attack"),'. BSC does introduce Slashing logic to penalize Byzantine validators for double signing or inavailability. This Slashing logic will expose the malicious validators in a very short time and make the "Clone Attack" very hard or extremely non-beneficial to execute.'),(0,n.kt)("h2",{id:"fast-finality"},"Fast Finality"),(0,n.kt)("p",null,"Finality is critical for blockchain security, once the block is finalized, it wouldn\u2019t be reverted anymore. The fast finality feature is very useful, the users can make sure they get the accurate information from the latest finalized block, then they can decide what to do next instantly. More details of design, please to refer ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/BEPs/blob/master/BEPs/BEP126.md"},"BEP-126")),(0,n.kt)("p",null,"Before the coming Plato upgrade,to secure as much as BC, BSC users are encouraged to wait until receiving blocks sealed by more than \u2154*N+1 different validators. In that way, the BSC can be trusted at a similar security level to BC and can tolerate less than \u2153","*","N Byzantine validators.With 21 validators, if the block time is 3 seconds, the \u2154","*","N+1 different validator seals will need a time period of (\u2154","*","21+1)","*","3 = 45 seconds. Any critical applications for BSC may have to wait for \u2154","*","N+1 to ensure a relatively secure finality. With above enhancement by slashing mechanism, \xbd","*","N+1 or even fewer blocks are enough as confirmation for most transactions."),(0,n.kt)("p",null,"After the coming Plato upgrade, the feature ",(0,n.kt)("inlineCode",{parentName:"p"},"Fast Finality")," will be enabled. The chain will be finalized within two blocks if \u2154*N or more validators vote normally, otherwise the chain has a fixed number of blocks to reach probabilistic finality as before."))}u.isMDXComponent=!0}}]);